[{"title":"Draft","type":0,"sectionRef":"#","url":"/immut/api/Draft","content":"On this page Draft Drafts are the backbone of Immut. They allow you to interact with a table in a way which would normally mutate it, but immutably. Internally, a draft stores a reference to the original table and then clones that table as soon as you modify it in any way.","keywords":""},{"title":"Immut","type":0,"sectionRef":"#","url":"/immut/api/Immut","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"Immut","url":"/immut/api/Immut#functions","content":" "},{"title":"makeDraftSafe​","type":1,"pageTitle":"Immut","url":"/immut/api/Immut#makeDraftSafe","content":"&lt;/&gt; Immut.makeDraftSafe(fn: T) → T A wrapper for functions that bypass metatables (like using rawset) that will make them draft-safe. makeDraftSafe is only necessary if the function will mutate the table. If the unsafe function is only reading from the table (using rawget), consider using original or current instead. This is used internally to wrap functions within Luau's table library, and is exposed for your convenience. local remove = makeDraftSafe(table.remove) local insert = makeDraftSafe(table.insert) local nextState = produce(state, function(draft) local value = remove(draft.a, 1) insert(draft.b, 1, value) end)   "},{"title":"isDraftable​","type":1,"pageTitle":"Immut","url":"/immut/api/Immut#isDraftable","content":"&lt;/&gt; Immut.isDraftable(value: any) → boolean Checks if a value can be wrapped with a draft. Tables without metatables are the only draftable values.  "},{"title":"isDraft​","type":1,"pageTitle":"Immut","url":"/immut/api/Immut#isDraft","content":"&lt;/&gt; Immut.isDraft(value: any) → boolean Checks if the given value is a draft.  "},{"title":"current​","type":1,"pageTitle":"Immut","url":"/immut/api/Immut#current","content":"&lt;/&gt; Immut.current(draft: Draft) → table Returns a snapshot of the current state of a draft. This can be expensive, so use it sparingly.  "},{"title":"finishDraft​","type":1,"pageTitle":"Immut","url":"/immut/api/Immut#finishDraft","content":"&lt;/&gt; Immut.finishDraft(draft: Draft) → table  tip It's unlikely you'll need to use this unless you have a very specific use case. Try using produce instead! Finalize a draft.  "},{"title":"produce​","type":1,"pageTitle":"Immut","url":"/immut/api/Immut#produce","content":"&lt;/&gt; Immut.produce( base: table,-- any table, so long as it doesn't have a metatable recipe: (draft: Draft) → any? ) → T The primary way to use Immut. Takes a table and a recipe function which is passed a draft that can be mutated, producing a new table with those changes made to it. Examples local state = { pets = { mittens = { type = &quot;cat&quot;, mood = &quot;lonely&quot;, }, } } -- mittens is lonely. let's get her a friend local newState = produce(state, function(draft) draft.pets.spot = { type = &quot;dog&quot;, mood = &quot;curious&quot;, } draft.pets.mittens.mood = &quot;happy&quot; end) Recipe functions do not need to return anything. When they do, the returned value will be used instead of the draft. local newState = produce(state, function(draft) return {} -- newState becomes an empty table end)   "},{"title":"original​","type":1,"pageTitle":"Immut","url":"/immut/api/Immut#original","content":"&lt;/&gt; Immut.original(draft: T) → () Returns the original table. You can use this to opt out of Immut for any table, like in cases where it may be more performant to use another method.  "},{"title":"createDraft​","type":1,"pageTitle":"Immut","url":"/immut/api/Immut#createDraft","content":"&lt;/&gt; Immut.createDraft(base: table) → Draft  tip It's unlikely you'll need to use this unless you have a very specific use case. Try using produce instead! Create a new draft from the given table. "},{"title":"table","type":0,"sectionRef":"#","url":"/immut/api/table","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"table","url":"/immut/api/table#functions","content":" "},{"title":"insert​","type":1,"pageTitle":"table","url":"/immut/api/table#insert","content":"&lt;/&gt; table.insert( t: {V}, pos: number, value: V ) → () https://create.roblox.com/docs/reference/engine/libraries/table#insert  "},{"title":"remove​","type":1,"pageTitle":"table","url":"/immut/api/table#remove","content":"&lt;/&gt; table.remove( t: {V}, pos: number? ) → V? https://create.roblox.com/docs/reference/engine/libraries/table#remove  "},{"title":"sort​","type":1,"pageTitle":"table","url":"/immut/api/table#sort","content":"&lt;/&gt; table.sort( t: {V}, comp: function ) → () https://create.roblox.com/docs/reference/engine/libraries/table#sort  "},{"title":"clear​","type":1,"pageTitle":"table","url":"/immut/api/table#clear","content":"&lt;/&gt; table.clear(t: {[K]: V}) → () https://create.roblox.com/docs/reference/engine/libraries/table#clear "},{"title":"About","type":0,"sectionRef":"#","url":"/immut/docs/intro","content":"","keywords":""},{"title":"Comparison​","type":1,"pageTitle":"About","url":"/immut/docs/intro#comparison","content":"Let's imagine we're making a game that has an immutable inventory system. We're going to decrease the durability of the player's sword by 10 and give them a health potion. local inventory = { weapons = { sword = { damage = 10, durability = 100, }, }, consumables = { staminaPotion = { value = 100, stamina = 20, }, }, }  "},{"title":"Manually​","type":1,"pageTitle":"About","url":"/immut/docs/intro#manually","content":"We can opt to do this ourselves by using table.clone, but we will need to be careful and make sure that we clone any table we intend to make changes to. This gets more and more difficult the deeper your state is nested. local newInventory = table.clone(inventory) -- let's handle the sword first newInventory.weapons = table.clone(inventory.weapons) newInventory.weapons.sword = table.clone(newInventory.weapons.sword) newInventory.weapons.sword.durability -= 10 -- now for the potion newInventory.consumables = table.clone(inventory.consumables) newInventory.consumables.healthPotion = { value = 100, health = 20, }  "},{"title":"Other libraries​","type":1,"pageTitle":"About","url":"/immut/docs/intro#other-libraries","content":"There's a few existing libraries that can help us out with this. They do a great job and make solving this problem way easier. Unfortunately, just like the manual method, they do have a bit of boilerplate. In this example, we're not using a specific library, but we're copying some common patterns they use. local Immutable = require(ReplicatedStorage.Immutable) local Dictionary = Immutable.Dictionary local newInventory = Dictionary.merge(inventory, { weapons = Dictionary.merge(inventory.weapons, { sword = Dictionary.update( inventory.weapons.sword, &quot;durability&quot;, function(value) return value - 10 end, ) }), consumables = Dictionary.merge(inventory.consumables, { healthPotion = { value = 100, health = 20, } }) })  "},{"title":"Immut​","type":1,"pageTitle":"About","url":"/immut/docs/intro#immut","content":"With Immut, we can solve this problem as if we weren't concerned with mutation at all. This makes it trivial. local Immut = require(ReplicatedStorage.Immut) local newInventory = Immut.produce(inventory, function(draft) draft.weapons.sword.durability -= 10 draft.consumables.healthPotion = { value = 100, health = 20, } end)  "},{"title":"How It Works​","type":1,"pageTitle":"About","url":"/immut/docs/intro#how-it-works","content":"Immut makes use of metatables to hide a lot of the complexity of working with immutable data in Luau. The first time you make a change to a draft, the original table is cloned and your changes are applied to that clone. When reading values from a draft, it will first try to read from a clone, and fall back to the original table if one doesn't exist. Immut won't clone anything if it doesn't need to. "},{"title":"Some caveats​","type":1,"pageTitle":"About","url":"/immut/docs/intro#some-caveats","content":"A draft is not the same as your original table! Keep that in mind when directly comparing two tables inside of a producer. produce(state, function(draft) print(state == draft) -- false end) produce(state, function(draft) print(original(draft) == state) -- true end) Nested tables are automatically turned into drafts. This can be convenient when dealing with nested state, like in our example above, but may not always be what you want. To remedy this, you can opt out of using a draft withImmut.original. Functions from Luau's built-in table library do not respect metatables. If you want to use them, Immut comes with Immut.table which offers some draft-safe replacements with the same functionality. "}]