[{"title":"Draft","type":0,"sectionRef":"#","url":"/immut/api/Draft","content":"On this page Draft Drafts are the backbone of Immut. They allow you to interact with a table in a way which would normally mutate it, but immutably. Internally, a draft stores a reference to the original table and then clones that table as soon as you modify it in any way.","keywords":""},{"title":"About","type":0,"sectionRef":"#","url":"/immut/docs/intro","content":"","keywords":""},{"title":"Comparison​","type":1,"pageTitle":"About","url":"/immut/docs/intro#comparison","content":"Let's imagine we're making a game that has an immutable inventory system. We're going to decrease the durability of the player's sword by 10 and give them a health potion. local inventory = { weapons = { sword = { damage = 10, durability = 100, }, }, consumables = { staminaPotion = { value = 100, stamina = 20, }, }, }  "},{"title":"Manually​","type":1,"pageTitle":"About","url":"/immut/docs/intro#manually","content":"We can opt to do this ourselves by using table.clone, but we will need to be careful and make sure that we clone any table we intend to make changes to. This gets more and more difficult the deeper your state is nested. local newInventory = table.clone(inventory) -- let's handle the sword first newInventory.weapons = table.clone(inventory.weapons) newInventory.weapons.sword = table.clone(newInventory.weapons.sword) newInventory.weapons.sword.durability -= 10 -- now for the potion newInventory.consumables = table.clone(inventory.consumables) newInventory.consumables.healthPotion = { value = 100, health = 20, }  "},{"title":"Other libraries​","type":1,"pageTitle":"About","url":"/immut/docs/intro#other-libraries","content":"There's a few existing libraries that can help us out with this. They do a great job and make solving this problem way easier. Unfortunately, just like the manual method, they do have a bit of boilerplate. In this example, we're not using a specific library, but we're copying some common patterns they use. local Immutable = require(ReplicatedStorage.Immutable) local Dictionary = Immutable.Dictionary local newInventory = Dictionary.merge(inventory, { weapons = Dictionary.merge(inventory.weapons, { sword = Dictionary.update( inventory.weapons.sword, &quot;durability&quot;, function(value) return value - 10 end, ) }), consumables = Dictionary.merge(inventory.consumables, { healthPotion = { value = 100, health = 20, } }) })  "},{"title":"Immut​","type":1,"pageTitle":"About","url":"/immut/docs/intro#immut","content":"With Immut, we can solve this problem as if we weren't concerned with mutation at all. This makes it trivial. local Immut = require(ReplicatedStorage.Immut) local newInventory = Immut.produce(inventory, function(draft) inventory.weapons.sword.durability -= 10 inventory.consumables.healthPotion = { value = 100, health = 20, } end)  "},{"title":"How It Works​","type":1,"pageTitle":"About","url":"/immut/docs/intro#how-it-works","content":"Immut makes use of metatables to hide a lot of the complexity of working with immutable data in Luau. The first time you make a change to a draft, the original table is cloned and your changes are applied to that clone. When reading values from a draft, it will first try to read from a clone, and fall back to the original table if one doesn't exist. Immut won't clone anything if it doesn't need to. "},{"title":"Some caveats​","type":1,"pageTitle":"About","url":"/immut/docs/intro#some-caveats","content":"A draft is not the same as your original table! Keep that in mind when directly comparing two tables inside of a producer. produce(state, function(draft) print(state == draft) -- false end) produce(state, function(draft) print(original(draft) == state) -- true end) Nested tables are automatically turned into drafts. This can be convenient when dealing with nested state, like in our example above, but may not always be what you want. To remedy this, you can opt out of using a draft withImmut.original. Luau's table library does not respect metatables. If you want to usetable.insert and table.remove, Immut comes with Immut.insert andImmut.remove, which are draft-safe alternatives that offer the same functionality. "},{"title":"Immut","type":0,"sectionRef":"#","url":"/immut/api/Immut","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"Immut","url":"/immut/api/Immut#functions","content":" "},{"title":"isDraftable​","type":1,"pageTitle":"Immut","url":"/immut/api/Immut#isDraftable","content":"&lt;/&gt; Immut.isDraftable(value: any) → boolean Checks if a value can be wrapped with a draft. Tables without metatables are the only draftable values.  "},{"title":"createDraft​","type":1,"pageTitle":"Immut","url":"/immut/api/Immut#createDraft","content":"&lt;/&gt; Immut.createDraft(base: table) → Draft  tip It's unlikely you'll need to use this unless you have a very specific use case. Try using produce instead! Create a new draft from the given table.  "},{"title":"isDraft​","type":1,"pageTitle":"Immut","url":"/immut/api/Immut#isDraft","content":"&lt;/&gt; Immut.isDraft(value: any) → boolean Checks if the given value is a draft.  "},{"title":"produce​","type":1,"pageTitle":"Immut","url":"/immut/api/Immut#produce","content":"&lt;/&gt; Immut.produce( base: table,-- any table, so long as it doesn't have a metatable recipe: (draft: Draft) → any? ) → T The primary way to use Immut. Takes a table and a recipe function which is passed a draft that can be mutated, producing a new table with those changes made to it. Examples local state = { pets = { mittens = { type = &quot;cat&quot;, mood = &quot;lonely&quot;, }, } } -- mittens is lonely. let's get her a friend local newState = produce(state, function(draft) draft.pets.spot = { type = &quot;dog&quot;, mood = &quot;curious&quot;, } draft.pets.mittens.mood = &quot;happy&quot; end) Recipe functions do not need to return anything. When they do, the returned value will be used instead of the draft. local newState = produce(state, function(draft) return {} -- newState becomes an empty table end)   "},{"title":"remove​","type":1,"pageTitle":"Immut","url":"/immut/api/Immut#remove","content":"&lt;/&gt; Immut.remove( draft: {V}, number: number? ) → V? Draft-safe replacement for table.remove  "},{"title":"insert​","type":1,"pageTitle":"Immut","url":"/immut/api/Immut#insert","content":"&lt;/&gt; Immut.insert( draft: {V}, pos: number | V, value: V? ) → () Draft-safe replacement for table.insert  "},{"title":"finishDraft​","type":1,"pageTitle":"Immut","url":"/immut/api/Immut#finishDraft","content":"&lt;/&gt; Immut.finishDraft(draft: Draft) → table  tip It's unlikely you'll need to use this unless you have a very specific use case. Try using produce instead! Finalize a draft.  "},{"title":"original​","type":1,"pageTitle":"Immut","url":"/immut/api/Immut#original","content":"&lt;/&gt; Immut.original(draft: T) → () Returns the original table. You can use this to opt out of Immut for any table, like in cases where it may be more performant to use another method. "}]